# Data-Structure-Agorithms
This is a repo for implementing different kinds of data structures and algorithms as training.

## Big O Notation
The `Big O notation` is a mathematical notation used in computer science to describe the performance or efficiency of an algorithm. It provides a way to analyze and compare the worst-case behavior of algorithms as the size of the input increases.

In Big O notation, an algorithm is represented by O(f(n)), where "f(n)" is a function that characterizes the algorithm's time complexity or space complexity in terms of the input size "n." The "O" stands for "order of" and represents the upper bound or worst-case scenario.

The function "f(n)" typically represents the number of operations or steps required by the algorithm to solve a problem of size "n." However, the exact number of operations is not important; what matters is how the algorithm's performance scales with increasing input size.

Here are some common Big O notations and examples of data structures that use them:

1. `O(1)` - Constant time complexity:
   * Examples: Array, Linked List (insertion and deletion at the beginning), Hash table (average case lookup)

2. `O(log n)` - Logarithmic time complexity:
   * Examples: Binary search tree (search, insertion, deletion), Balanced binary search tree (e.g., AVL tree, Red-Black tree)

3. `O(n)` - Linear time complexity:
   * Examples: Array (search, traversal), Linked List (search, traversal), Queue, Stack, Hash table (worst case lookup)

4. `O(n log n)` - Linearithmic time complexity:
   * Examples: Merge Sort, Quick Sort, Heap Sort

5. `O(n^2)` - Quadratic time complexity:
   * Examples: Bubble Sort, Insertion Sort, Selection Sort

6. `O(2^n)` - Exponential time complexity:
   * Examples: Traveling Salesman Problem (brute force), Subset Generation (powerset generation)

These are just a few examples of common time complexities and the data structures or algorithms that exhibit them. It's worth noting that there are many other complexities and variations beyond these. The choice of data structure and algorithm depends on the specific problem at hand, the expected input size, and the desired trade-offs between time complexity and other factors such as memory usage.

![BigONotation](https://github.com/omarsamy3/Data-Structure-Agorithms/assets/76973221/58645f89-7da2-432a-96ab-a3a1772a4cba)
